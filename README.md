# Maven版本管理控制

##一、maven版本

	快照版本：快照版本使用在开发的过程中，方便于团队内部交流学习
	稳定版本：理想状态下是项目到了某个比较稳定的状态，这个稳定包含了源代码和构建都要稳定。


>如何衡量项目的稳定状态呢？
1. 所有的自动化测试应当全部通过
2. 项目没有配置任何快照版本的依赖
3. 项目没有配置任何快照版本的插件
4. 项目所包含的代码都已经全部提交到了版本控制系统中
5. 我们应当再一次执行Maven构建，以确保项目的状态是OK的
6. 我们将这一次变更提交到版本控制的主干中，并打上标签

## 二、版本号变更规则
###举例
>例如：1.2.3-beta-4.jar
“1” :  表示该版本的第一个重大版本
“2” :  表示这是基于重大版本的第二个次要版本
“3” :  表示该次要版本的第三个增量
“beta-4” : 表示该增量的一个里程碑

###图形描述
>< 主版本 >  ------   < 次版本 > ------ < 增量版本 > ------ < 里程碑版本 >
>
	主版本：表示了项目的重大架构变更  struts1 --  struts2
	次版本：表示较大范围的功能增加和变化  Nexus1.5 ----   Nexus1.4
	增量版本：一般表示重大Bug修复
	里程碑版本：指某一个版本的里程碑   *.*-alpha-1  *.*-beta-1


 >功能的开发测试阶段使用 alpha->beta->rc->正式版 的顺序来标识
 >
	alpha :内测版,问题较多
	beta:公测版，问题较少
	rc:release candidate 发行侯选版本，已经非常接近正式版只有少许bug

>一般来说，我们只会声明主版本和次版本，增量版本和里程碑版本就不一定需要


##三、主干、分支、标签
	主干: 项目开发代码的主体，是从项目开始到当前都处于活动的状态，从这里可以获得项目最新的源代码和几乎所有的变更历史
	分支: 从主干的某个点分离出来的代码拷贝，通常可以在不影响主干的前提下，在这里进行重大的bug修复或者实验性质的开发，如果达到了预期的目的，通常将这里的变更合并到主干中去。
	标签: 用来标识主干或者分支的某个点的状态，以代表项目的某个稳定状态，也就是通常说的发布状态
###常用分支
	develop 分支：这是我们的开发分支，所有新功能的开发都在这个分支上。
	master 分支：功能开发测试完毕合并到master分支，[该分支为备份作用，可以直接用该分支作为开发分支]
	1.0.x分支 ,当1.0版本功能开发测试完成后，分离的分支，如果1.0版本有问题，可以直接切到该分支进行维护升级，维护的过程可以用git 创建tag作为一个阶段的正式版本
	1.2.x分支，当1.2版本功能开发测试完成后，分离的分支，如果1.2版本有问题，可以直接切到该分支进行维护升级，维护的过程可以用git 创建tag作为一个阶段的正式版本

##四、自动化版本发布
>使用maven插件Maven Release >Plugin（http://maven.apache.org/maven-release/maven->release-plugin/usage.html）,该插件主要有三个目
>标:release: prepare,  release: rollback,  release: perform

>(1)release:prepare准备版本发布，依次执行下列操作
>>		1. 检查项目是否有未提交的代码
>>		2. 检查项目是否有快照版本依赖
>>		3. 根据用户的输入将快照版本升级为发布版
>>		4. 将POM中的SCM信息更新为标签地址
>>		5. 基于修改后的POM执行maven构建
>>		6. 提交POM变更
>>		7. 基于用户输入为代码打标签
>>		8. 将代码从发布版升级为新的快照版
>>		9.提交POM变更
>
>(2)release: rollback
>回退release: prepare所执行的操作。将POM回退至release:prepare之前的状态，并提交。
>>		注：该步骤不会删除release:prepare生成的标签，需要用户手动删除住着使用release:clean删除
>
>(3)release: perform
>执行版本发布,签出release:prepare生成的标签中的源代码，
>并在此基础上执行mvn deploy命令打包并部署构件至仓库
>>		注：要为项目发布版本，首先需要为其添加正确的版本控制系统信息(这是因为Maven Release Plugin需要知道版本控制系统的主干、标签等地址后才能执行相关操作)
##五、代码安全
 >使用Maven GPG Plugin 自动的完成签名


(一)设计模式的分类
     总体来说设计模式分为三大类：
     创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
     结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
     行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
     其实还有两类：并发型模式和线程池模式。
(二)设计模式的六大原则
1、开闭原则（Open Close Principle）
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
    里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3、依赖倒转原则（Dependence Inversion Principle）
    这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
    这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5、迪米特法则（最少知道原则）（Demeter Principle）
    为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
    原则是尽量使用合成/聚合的方式，而不是使用继承。
